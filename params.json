{"name":"Reskin","tagline":"Android换肤库","body":"## 使用方法\r\n## 1 换肤主题\r\n换肤主题在`SkinTheme`里枚举定义。库默认定义了三个主题-默认主题、日间主题和夜间主题。要扩展主题只需仿照BLACK，传入后缀名即可：\r\n```java\r\nBLACK(\"_blackmode\") {\r\n    @Override\r\n    int getId(int resId, String defType) {\r\n        return getNewResId(resId, getSuffix(), defType);\r\n    }\r\n};\r\n```\r\n后缀名用作换肤资源的命名。\r\n## 2 换肤资源\r\n换肤资源的定义只需注意资源的命名。将换肤资源命名为默认资源+换肤主题后缀即可。如color值：\r\n```xml\r\n<color name=\"textColor\">#FF4081</color>\r\n<color name=\"textColor_whitemode\">#3F51B5</color>\r\n<color name=\"textColor_blackmode\">#8F5230</color>\r\n```\r\n图片资源命名，如image.png对应的夜间主题资源为image_blackmode.png。\r\n## 3 实现换肤\r\n使用换肤库全面实现整个App的换肤功能，需要从Android的Application/Activity/Fragment/View层分别操作。\r\n#### 3.1 Application\r\n应用启动时初始化传入Context，在应用Application `onCreate()`里添加：\r\n```java\r\nSkinManager.init(this);\r\n```\r\n#### 3.2 Activity\r\n支持换肤功能的Activity需继承`BaseSkinActivity`。`BaseSkinActivity`继承了`FragmentActivity`。\r\n```java\r\npublic class MainActivity extends BaseSkinActivity {\r\n    ...\r\n}\r\n```\r\nActivity里需使用LayoutInflate的，应通过当前Activity的`getLayoutInfater()`获取。\r\n#### 3.3 Fragment\r\n支持换肤功能的Fragment需继承`BaseSkinFragment`。在`onCreateView()`时设置Fragment布局，应使用参数里提供的`infalter`。\r\n```java\r\npublic class MyFragment extends BaseSkinFragment {\r\n    ...\r\n    @Override\r\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\r\n        return inflater.inflate(R.layout.fragment_b, container, false);\r\n    }\r\n    ...\r\n}\r\n```\r\nFragment里其它地方需使用LayoutInflate的，应通过当前Fragment的`getLayoutInfater(null)`获取。\r\n#### 3.4 View\r\n##### 3.4.1 系统原生View\r\n###### - xml布局中\r\n不用操作，全都由换肤库自行管理。\r\n###### - 手动addView\r\n需要将View及其换肤关注属性添加到换肤管理。\r\n```java\r\n/** 动态添加系统View */\r\nLinearLayout linearLayout = (LinearLayout) findViewById(R.id.root);\r\nTextView tv = new TextView(this);\r\nint colorResId = R.color.textColor;\r\ntv.setTextColor(getResources().getColor(colorResId));\r\nlinearLayout.addView(tv);\r\n\r\n/** 动态添加系统View不走onCreateView,需要手动添加换肤关注属性 */\r\nList<DynamicViewAttribute> attrs = new ArrayList<>();\r\nattrs.add(new DynamicViewAttribute(\"textColor\", colorResId));\r\naddSkinView(tv, attrs);\r\n```\r\n注意，`DynamicViewAttribute`里添加的资源id为默认主题的资源id。\r\n###### 原生View支持的换肤资源类型有@color/@drawable，具体View类型的支持情况如下：\r\n| View      | 属性                                       | 资源类型             |\r\n| --------- | :--------------------------------------- | :--------------- |\r\n| View      | background                               | @color/@drawable |\r\n| TextView  | textColor                                | @color           |\r\n| TextView  | drawableLeft/drawableTop/drawableRight/drawableBottom | @drawable        |\r\n| ImageView | src                                      | @drawable        |\r\n| ListView  | divider                                  | @color           |\r\n| AbsListView  | listSelector     | @drawable           |\r\n注：手动addView暂不支持TextView的drawableLeft/drawableTop/drawableRight/drawableBottom属性。\r\n##### 3.4.2 有自定义属性的自定义View\r\n自定义View的基类如果是以上提到的View，对应支持的换肤属性按系统View处理，不接受自定义View的规则。\r\n若以上系统View的原生属性不能满足自定义View的换肤需求，自定义View需：\r\n- 实现`ICustomSkinView`接口，在`reSkin(SkinTheme)`里获取皮肤资源并设置。注意，自行实现了onDraw()的自定义View，reSkin()应先取theme下的属性值，再调用`invalidate()`刷新View。\r\n- 在`onAttachedToWindow()`/`onDetachedFromWindow()`添加/移除换肤管理，无需关注是在布局xml中还是手动addView()。注意该View是否属于Fragment，属于Fragment添加到Fragment的换肤管理，否则添加到Activity的换肤管理。\r\n\r\n以下两个小例子说明以上两点。\r\n\r\n\r\n自行实现`onDraw()`的自定义View，在Activity中：\r\n```java\r\npublic class CustomView extends View implements ICustomSkinView {\r\n    ...\r\n    @Override\r\n    protected void onDraw(Canvas canvas) {\r\n        super.onDraw(canvas);\r\n        mPaint.setColor(mColor);\r\n        ...\r\n    }\r\n\r\n    @Override\r\n    protected void onAttachedToWindow() {\r\n        super.onAttachedToWindow();\r\n        mActivity.addCustomView(this);\r\n    }\r\n\r\n    @Override\r\n    protected void onDetachedFromWindow() {\r\n        super.onDetachedFromWindow();\r\n        try {\r\n            mActivity.removeCustomView(this);\r\n        } catch (NullPointerException e) {\r\n            // 异常不需处理\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void reSkin(SkinTheme theme) {\r\n        mColor = theme.getColor(R.color.textColor);\r\n\r\n        invalidate();\r\n    }\r\n}\r\n```\r\n支持TextView的linkTextColor属性换肤，在Fragment中：\r\n```java\r\npublic class CustomTextView extends TextView implements ICustomSkinView {\r\n    int mColor;\r\n    ...\r\n    @Override\r\n    public void reSkin(SkinTheme theme) {\r\n        mColor = theme.getColor(R.color.linkColor);\r\n\r\n        setLinkTextColor(mColor);\r\n    }\r\n\r\n    @Override\r\n    protected void onAttachedToWindow() {\r\n        super.onAttachedToWindow();\r\n        mFragment.addCustomView(this);\r\n    }\r\n\r\n    @Override\r\n    protected void onDetachedFromWindow() {\r\n        super.onDetachedFromWindow();\r\n        try {\r\n            mFragment.removeCustomView(this);\r\n        } catch (NullPointerException e) {\r\n        }\r\n    }\r\n}\r\n```\r\n#### 3.5 触发换肤\r\n触发换肤时，应调用库中API`SkinManager.reSkin(SkinTheme, BaseSkinActivity)`，参数传入目标主题和当前所在Activity。\r\n其它Activity的换肤会在`onResume()`自行完成，不需主动触发。\r\n```java\r\nvoid changeSkin(SkinTheme targetTheme) {\r\n    SkinManager.reSkin(targetTheme, BaseActivity.this);\r\n}\r\n```\r\n触发换肤的Activity如果有Fragment，理论上应主动调用每个可见Fragment的reSkin()以实现当前界面的换肤(因为Fragment的onResume调不到了)。\r\n\r\n## Tips\r\n1. 触发换肤后EventBus会post出全局事件ReskinEvent。有自定义需求的地方需要向EventBus进行注册/反注册,并实现onEvent(ReskinEvent)方法。换肤主题可通过`ReskinEvent.getTheme()`获取。\r\n2. 使用系统的Color.Black或者在代码里硬编码资源(如直接把color的数值写在Java代码或布局xml里)的地方，需在xml里自定义资源。\r\n3. 根据View是否在Fragment使用正确的LayoutInflater。Adapter在Activity/Fragment都可以使用，Adapter里需要使用LayoutInflate，应通过构造函数或者另开`setLayoutInflater(LayoutInflater)`接受参数。参数传递时UI应确定Adapter是否在Fragment的View里使用，获取正确的LayoutInflater。\r\n4. 有自定义属性的自定义View根据View是否在Fragment使用正确的换肤管理。有自定义属性的自定义View在Activity/Fragment都可以使用，添加/移除自身到换肤管理时，应注意当前View是否在Fragment里使用。在Fragment里使用应添加到Fragment的换肤管理，直接被Activity使用应添加到Activity的换肤管理。\r\n5. 有自定义属性的自定义View在退出一个界面时，onDetachedFromWindow()中移除换肤管理时可能出现Activity/Fragment已被销毁，应添加`try{}catch{}`保护。\r\n6. 关于xml布局中系统原生View使用中间量资源。中间量资源只提供命名，不承载具体资源。如以下bg_temp就是一个临时color资源。这样的资源在布局时，从属性里读取的资源id为bg的id，而不是bg_temp的id。\r\n```xml\r\n<color name=\"bg_temp\">@color/bg</color>\r\n<color name=\"bg\">#FF0000</color>\r\n```\r\n相应的，在主题资源命名时，应使用承载了具体资源值的资源。\r\n```xml\r\n<color name=\"bg\">#FF0000</color>\r\n<color name=\"bg_whitemode\">#00FF00</color>\r\n<color name=\"bg_blackmode\">#0000FF</color>\r\n```\r\n中间量资源资源id的变化只针对这种情况，其它情况不受影响。\r\n7. selector是文件级别资源，实现换肤要新建文件，命名为原文件名+主题后缀的形式。","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
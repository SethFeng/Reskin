{"name":"Reskin","tagline":"Android换肤库","body":"## 使用方法\r\n## 1 换肤主题\r\n换肤主题在`SkinTheme`里枚举定义。库默认定义了两个主题-默认主题和夜间主题。要增加主题只需仿照NIGHT，传入后缀名即可：\r\n```java\r\nTHIRD(\"_third\") {\r\n    @Override\r\n    int getId(int resId, String defType) throws Resources.NotFoundException {\r\n        return getNewResId(resId, getSuffix(), defType);\r\n    }\r\n};\r\n```\r\n后缀名用作换肤资源的命名。\r\n## 2 换肤资源\r\n换肤资源的命名只需将默认资源重命名属性名时添加换肤主题对应的后缀名即可。如color值：\r\n```xml\r\n<color name=\"textColor\">#FF4081</color>\r\n<color name=\"textColor_night\">#3F51B5</color>\r\n<color name=\"textColor_third\">#8F5230</color>\r\n```\r\n图片资源命名添加换肤主题的后缀即可。如image.png对应的夜间主题资源为image_night.png。\r\n## 3 实现换肤\r\n使用换肤库全面实现整个App的换肤功能，需要从Android的Application/Activity/Fragment/View层分别操作。\r\n#### 3.1 Application\r\n应用启动时初始化传入Context，在应用Application `onCreate()`里添加：\r\n```java\r\nSkinManager.init(this);\r\n```\r\n#### 3.2 Activity\r\n支持换肤功能的Activity需继承`BaseSkinActivity`。`BaseSkinActivity`继承了`FragmentActivity`。\r\n```java\r\npublic class MainActivity extends BaseSkinActivity {\r\n    ...\r\n}\r\n```\r\n#### 3.3 Fragment\r\n支持换肤功能的Fragment需继承`BaseSkinFragment`。在`onCreateView()`时设置Fragment布局，应使用Activity的LayoutInflater(`getActivity().getLayoutInflater()`/`LayoutInflater.from(getActivity())`)。\r\n```java\r\npublic class MyFragment extends BaseSkinFragment {\r\n    ...\r\n    @Override\r\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\r\n        return getActivity().getLayoutInflater().inflate(R.layout.fragment_b, container, false);\r\n    }\r\n    ...\r\n}\r\n```\r\n#### 3.4 View\r\n##### 3.4.1 系统原生View\r\n###### - xml布局中\r\n不用操作，全都由换肤库自行管理。\r\n###### - 手动addView\r\n需要将View及其换肤关注属性添加到换肤管理。\r\n```java\r\n/** 动态添加系统View */\r\nLinearLayout linearLayout = (LinearLayout) findViewById(R.id.root);\r\nTextView tv = new TextView(this);\r\nint colorResId = R.color.textColor;\r\ntv.setTextColor(getResources().getColor(colorResId));\r\nlinearLayout.addView(tv);\r\n\r\n/** 动态添加系统View不走onCreateView,需要手动添加换肤关注属性 */\r\nList<DynamicViewAttribute> attrs = new ArrayList<>();\r\nattrs.add(new DynamicViewAttribute(\"textColor\", colorResId));\r\naddSkinView(tv, attrs);\r\n```\r\n##### 3.4.2 自定义View\r\n自定义View需按以下规则定义，不需关心是在布局xml中还是手动addView。\r\n###### - 直接继承`android.view.View`\r\n直接继承`android.view.View`的自定义View，修改让其继承自CustomSkinView，在`initSKinRes()`初始化属性值，在`reSkin()`更新属性值并主动调用`invalidate()`更新View。\r\n```java\r\npublic class SkinnableView extends CustomSkinView {\r\n    private String mText;\r\n\r\n    public SkinnableView(Context context) {\r\n        super(context);\r\n    }\r\n\r\n    public SkinnableView(Context context, AttributeSet attrs) {\r\n        super(context, attrs);\r\n    }\r\n\r\n    public SkinnableView(Context context, AttributeSet attrs, int defStyleAttr) {\r\n        super(context, attrs, defStyleAttr);\r\n    }\r\n\r\n    @Override\r\n    public void initSKinRes() {\r\n        /** 赋值:系统默认值 */\r\n        mText = getResources().getString(R.string.demo_text);\r\n\r\n        /** 若当前主题不是默认主题,需要更改属性值 */\r\n        if (SkinManager.getTheme() != SkinTheme.DEFAULT) {\r\n            try {\r\n                mText = getResources().getString(SkinManager.getTheme().getId(R.string.demo_text));\r\n            } catch (Resources.NotFoundException e) {\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void onDraw(Canvas canvas) {\r\n        super.onDraw(canvas);\r\n        canvas.drawText(mText, ...);\r\n    }\r\n\r\n    @Override\r\n    public void reSkin(SkinTheme theme) {\r\n        /** 必须try catch资源找不到时的异常，异常可不处理 */\r\n        try {\r\n            mText = getResources().getString(theme.getId(R.string.demo_text));\r\n        } catch (Resources.NotFoundException e) {\r\n        }\r\n\r\n        /** 更改属性值后刷新View */\r\n        invalidate();\r\n    }\r\n}\r\n```\r\n###### - 非直接继承`android.view.View`\r\n继承其它View的自定义View，需要自行实现`ICustomSkinView`接口，实现`initSKinRes()`和`reSkin()`方法。在`onAttachedToWindow()`/`onDetachedFromWindow()`添加/移除换肤管理。\r\n```java\r\npublic class CustomLinearLayout extends LinearLayout implements ICustomSkinView {\r\n    private int mColor;\r\n\r\n    public CustomLinearLayout(Context context) {\r\n        super(context);\r\n        initSKinRes();\r\n    }\r\n\r\n    public CustomLinearLayout(Context context, AttributeSet attrs) {\r\n        super(context, attrs);\r\n        initSKinRes();\r\n    }\r\n\r\n    public CustomLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) {\r\n        super(context, attrs, defStyleAttr);\r\n        initSKinRes();\r\n    }\r\n\r\n    @Override\r\n    public void initSKinRes() {\r\n        mColor = getResources().getColor(R.color.textColor);\r\n        if (SkinManager.getTheme() != SkinTheme.DEFAULT) {\r\n            try {\r\n                mColor = SkinManager.getTheme().getColor(R.color.textColor);\r\n            } catch (Resources.NotFoundException e) {\r\n            }\r\n        }\r\n        setBackgroundColor(mColor);\r\n    }\r\n\r\n    @Override\r\n    public void reSkin(SkinTheme theme) {\r\n        try {\r\n            mColor = theme.getColor(R.color.textColor);\r\n        } catch (Resources.NotFoundException e) {\r\n        }\r\n        setBackgroundColor(mColor);\r\n    }\r\n\r\n    @Override\r\n    protected void onAttachedToWindow() {\r\n        super.onAttachedToWindow();\r\n        ((BaseSkinActivity) getContext()).addCustomView(this);\r\n    }\r\n\r\n    @Override\r\n    protected void onDetachedFromWindow() {\r\n        super.onDetachedFromWindow();\r\n        ((BaseSkinActivity) getContext()).removeCustomView(this);\r\n    }\r\n}\r\n```\r\n#### 3.5 触发换肤\r\n触发换肤的Activity主动设置全局的换肤主题，并通过调用`reSkin()`主动触发本Activity的换肤。其它Activity的换肤会在`onResume()`自行完成，不需主动触发。\r\n```java\r\npublic void changeSkin(SkinTheme targetTheme) {\r\n    SkinManager.reSkin(targetTheme);\r\n    reSkin(targetTheme);\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}